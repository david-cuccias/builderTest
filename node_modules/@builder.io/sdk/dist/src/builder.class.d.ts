/// <reference types="node" />
import './polyfills/custom-event-polyfill';
import { IncomingMessage, ServerResponse } from 'http';
import { nextTick } from './functions/next-tick.function';
import { BehaviorSubject } from './classes/observable.class';
import { throttle } from './functions/throttle.function';
import { Animator } from './classes/animator.class';
import { BuilderElement } from './types/element';
import Cookies from './classes/cookies.class';
import { BuilderContent } from './types/content';
export declare type Url = any;
export declare const isReactNative: boolean;
export declare const validEnvList: string[];
export declare const isBrowser: boolean;
export declare const isIframe: boolean;
export interface ParamsMap {
    [key: string]: any;
}
declare type TrackingHook = (eventData: Event, context: {
    content?: BuilderContent;
    [key: string]: any;
}) => Event | undefined;
interface EventData {
    contentId?: string;
    ownerId: string;
    variationId?: string;
    userAttributes?: any;
    targetSelector?: string;
    targetBuilderElement?: string;
    unique?: boolean;
    metadata?: any | string;
    meta?: any | string;
    sessionId?: string;
    visitorId?: string;
    amount?: number;
}
interface Event {
    type: string;
    data: EventData;
}
export interface UserAttributes {
    urlPath?: string;
    queryString?: string | ParamsMap;
    device?: 'mobile' | 'tablet' | 'desktop';
    location?: any;
    userAgent?: string;
    referrer?: string;
    entryMedium?: string;
    language?: string;
    browser?: string;
    cookie?: string;
    newVisitor?: boolean;
    operatingSystem?: string;
}
export interface GetContentOptions {
    userAttributes?: UserAttributes;
    url?: string;
    includeUrl?: boolean;
    cacheSeconds?: number;
    staleCacheSeconds?: number;
    limit?: number;
    query?: any;
    cachebust?: boolean;
    prerender?: boolean;
    extractCss?: boolean;
    offset?: number;
    initialContent?: any;
    model?: string;
    cache?: boolean;
    preview?: boolean;
    entry?: string;
    alias?: string;
    fields?: string;
    omit?: string;
    key?: string;
    format?: 'amp' | 'email' | 'html';
    noWrap?: true;
    rev?: string;
    static?: boolean;
    options?: {
        [key: string]: any;
    };
}
export declare type Class = {
    name?: string;
    new (...args: any[]): any;
};
interface Map<K, V> {
    clear(): void;
    delete(key: K): boolean;
    entries(): IterableIterator<[K, V]>;
    forEach(callbackfn: (value: V, index: K, map: Map<K, V>) => void, thisArg?: any): void;
    get(key: K): V;
    has(key: K): boolean;
    keys(): IterableIterator<K>;
    set(key: K, value?: V): Map<K, V>;
    size: number;
    values(): IterableIterator<V>;
    [Symbol.iterator](): IterableIterator<[K, V]>;
}
export interface Input {
    name: string;
    friendlyName?: string;
    description?: string;
    defaultValue?: any;
    type: string;
    required?: boolean;
    autoFocus?: boolean;
    subFields?: Input[];
    helperText?: string;
    allowedFileTypes?: string[];
    imageHeight?: number;
    imageWidth?: number;
    mediaHeight?: number;
    mediaWidth?: number;
    hideFromUI?: boolean;
    modelId?: string;
    options?: {
        [key: string]: any;
    };
    enum?: string[] | {
        label: string;
        value: any;
        helperText?: string;
    }[];
    /** Regex field validation for all string types (text, longText, html, url, etc) */
    regex?: {
        /** pattern to test, like "^\/[a-z]$" */
        pattern: string;
        /** flags for the RegExp constructor, e.g. "gi"  */
        options?: string;
        /**
         * Friendly message to display to end-users if the regex fails, e.g.
         * "You must use a relative url starting with '/...' "
         */
        message: string;
    };
    advanced?: boolean;
    onChange?: Function | string;
    code?: boolean;
    richText?: boolean;
    showIf?: ((options: Map<string, any>) => boolean) | string;
}
export interface Component {
    /**
     * Name your component something unique, e.g. 'MyButton'. You can override built-in components
     * by registering a component with the same name, e.g. 'Text', to replace the built-in text component
     */
    name: string;
    description?: string;
    /**
     * Link to a documentation page for this component
     */
    docsLink?: string;
    image?: string;
    /**
     * Input schema for your component for users to fill in the options
     */
    inputs?: Input[];
    class?: any;
    type?: 'angular' | 'webcomponent' | 'react' | 'vue';
    defaultStyles?: {
        [key: string]: string;
    };
    /**
     * Turn on if your component can accept children. Be sure to use in combination with
     * withChildren(YourComponent) like here
     * github.com/BuilderIO/builder/blob/master/examples/react-design-system/src/components/HeroWithChildren/HeroWithChildren.builder.js#L5
     */
    canHaveChildren?: boolean;
    fragment?: boolean;
    /**
     * Do not wrap a component in a dom element. Be sure to use {...props.attributes} with this option
     * like here github.com/BuilderIO/builder/blob/master/packages/react/src/blocks/forms/Input.tsx#L34
     */
    noWrap?: boolean;
    /**
     * Default children
     */
    defaultChildren?: BuilderElement[];
    defaults?: Partial<BuilderElement>;
    hooks?: {
        [key: string]: string | Function;
    };
    hideFromInsertMenu?: boolean;
    tag?: string;
    static?: boolean;
    /**
     * Specify restrictions direct children must match
     */
    childRequirements?: {
        /** Message to show when this doesn't match, e.g. "Children of 'Columns' must be a 'Column'" */
        message: string;
        /** Simple way to say children must be a specific component name */
        component?: string;
        /**
         * More advanced - specify a MongoDB-style query (using sift.js github.com/crcn/sift.js)
         * of what the children objects should match, e.g.
         *
         * @example
         *  query: {
         *    // Child of this element must be a 'Button' or 'Text' component
         *    'component.name': { $in: ['Button', 'Text'] }
         *  }
         */
        query?: any;
    };
    /**
     * Specify restrictions any parent must match
     */
    requiresParent?: {
        /** Message to show when this doesn't match, e.g. "'Add to cart' buttons must be within a 'Product box'" */
        message: string;
        /** Simple way to say a parent must be a specific component name, e.g. 'Product box' */
        component?: string;
        /**
         * More advanced - specify a MongoDB-style query (using sift.js github.com/crcn/sift.js)
         * of what at least one parent in the parents hierarchy should match, e.g.
         *
         * @example
         *  query: {
         *    // Thils element must be somewhere inside either a 'Product box' or 'Collection' component
         *    'component.name': { $in: ['Product Box', 'Collection'] }
         *  }
         */
        query?: any;
    };
    /** not yet implemented */
    friendlyName?: string;
}
declare type DeepPartial<T> = {
    [P in keyof T]?: T[P] extends Array<infer U> ? Array<DeepPartial<U>> : T[P] extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : DeepPartial<T[P]>;
};
export interface InsertMenuItem {
    name: string;
    icon?: string;
    item: DeepPartial<BuilderElement>;
}
export interface InsertMenuConfig {
    name: string;
    priority?: number;
    persist?: boolean;
    advanced?: boolean;
    items: InsertMenuItem[];
}
export declare function BuilderComponent(info?: Partial<Component>): (component: Class) => Class;
declare type Settings = any;
export interface Action {
    name: string;
    inputs?: Input[];
    returnType?: Input;
    action: Function | string;
}
export declare class Builder {
    protected request?: IncomingMessage | undefined;
    protected response?: ServerResponse | undefined;
    static VERSION: string;
    static components: Component[];
    static singletonInstance: Builder;
    static useNewApi: boolean;
    static isStatic: boolean;
    static animator: Animator;
    static nextTick: typeof nextTick;
    static throttle: typeof throttle;
    authToken: string;
    static editors: any[];
    static trustedHosts: string[];
    static plugins: any[];
    static actions: Action[];
    static registry: {
        [key: string]: any[];
    };
    /**
     * @todo `key` property on any info where if a key matches a current
     * key it gets removed
     */
    static register(type: 'insertMenu', info: InsertMenuConfig): void;
    static register(type: string, info: any): void;
    static registryChange: BehaviorSubject<{
        [key: string]: any[];
    }, any>;
    static registerEditor(info: any): void;
    static registerPlugin(info: any): void;
    static registerAction(action: Action): void;
    static registerTrustedHost(host: string): void;
    static isTrustedHost(hostname: string): boolean;
    static runAction(action: Action | string): void;
    static fields(name: string, fields: Input[]): void;
    private static _editingPage;
    static isIframe: boolean;
    static isBrowser: boolean;
    static isReactNative: boolean;
    static isServer: boolean;
    static previewingModel: string | false | null;
    static settings: Settings;
    static settingsChange: BehaviorSubject<any, any>;
    static set(settings: Settings): void;
    static import(packageName: string): any;
    static isEditing: boolean;
    static isPreviewing: boolean;
    static get editingPage(): boolean;
    static set editingPage(editingPage: boolean);
    private static prepareComponentSpecToSend;
    static registerComponent(component: any, options: Component): void;
    private static addComponent;
    static component(info?: Partial<Component>): (component: Class) => Class;
    static isReact: boolean;
    static get Component(): typeof Builder.component;
    private eventsQueue;
    private throttledClearEventsQueue;
    private processEventsQueue;
    env: string;
    sessionId: string;
    targetContent: boolean;
    contentPerRequest: number;
    allowCustomFonts: boolean;
    private cookies;
    private cachebust;
    private overrideParams;
    private noCache;
    private preview;
    get browserTrackingDisabled(): boolean;
    get canTrack(): boolean;
    set canTrack(canTrack: boolean);
    private canTrack$;
    private apiKey$;
    userAttributesChanged: BehaviorSubject<any, any>;
    get editingMode(): boolean;
    set editingMode(value: boolean);
    editingMode$: BehaviorSubject<boolean, any>;
    get editingModel(): string | null;
    set editingModel(value: string | null);
    private findParentElement;
    private findBuilderParent;
    editingModel$: BehaviorSubject<string | null, any>;
    setUserAgent(userAgent: string): void;
    userAgent: string;
    trackingHooks: TrackingHook[];
    /**
     * Set a hook to modify events being tracked from builder, such as impressions and clicks
     *
     * For example, to track the model ID of each event associated with content for querying
     * by mode, you can do
     *
     *    builder.setTrackingHook((event, context) => {
     *      if (context.content) {
     *        event.data.metadata.modelId = context.content.modelId
     *      }
     *    })
     */
    setTrackingHook(hook: TrackingHook): void;
    track(eventName: string, properties?: Partial<EventData>, context?: any): void;
    getSessionId(): string;
    visitorId: string;
    getVisitorId(): string;
    trackImpression(contentId: string, variationId?: string, properties?: any, context?: any): void;
    trackConversion(amount?: number, customProperties?: any): void;
    autoTrack: boolean;
    useNewContentApi: boolean;
    private get isDevelopmentEnv();
    trackInteraction(contentId: string, variationId?: string, alreadyTrackedOne?: boolean, event?: MouseEvent, context?: any): void;
    static overrideUserAttributes: Partial<UserAttributes>;
    trackingUserAttributes: {
        [key: string]: any;
    };
    component(info?: Partial<Component>): (component: Class) => Class;
    get apiKey(): string | null;
    set apiKey(key: string | null);
    constructor(apiKey?: string | null, request?: IncomingMessage | undefined, response?: ServerResponse | undefined, forceNewInstance?: boolean);
    private modifySearch;
    setTestsFromUrl(): void;
    resetOverrides(): void;
    getOverridesFromQueryString(): void;
    private messageFrameLoaded;
    private blockContentLoading;
    private bindMessageListeners;
    observersByKey: {
        [key: string]: BehaviorSubject<BuilderContent[]> | undefined;
    };
    get defaultCanTrack(): boolean;
    init(apiKey: string, canTrack?: boolean, req?: IncomingMessage, res?: ServerResponse): this;
    getLocation(): Url;
    getUserAttributes(userAgent?: string): UserAttributes;
    protected overrides: {
        [key: string]: string;
    };
    private getContentQueue;
    private priorContentQueue;
    setUserAttributes(options: object): void;
    /**
     * Set user attributes just for tracking purposes.
     *
     * Do this so properties exist on event objects for querying insights, but
     * won't affect targeting
     *
     * Use this when you want to track properties but don't need to target off
     * of them to optimize cache efficiency
     */
    setTrackingUserAttributes(attributes: object): void;
    get(modelName: string, options?: GetContentOptions & {
        req?: IncomingMessage;
        res?: ServerResponse;
        apiKey?: string;
    }): BehaviorSubject<any, any>;
    queueGetContent(modelName: string, options?: GetContentOptions): BehaviorSubject<BuilderContent[], any>;
    requestUrl(url: string): Promise<any>;
    get host(): string;
    private flushGetContentQueue;
    private testCookiePrefix;
    private processResultsForTests;
    private getTestCookie;
    private cookieQueue;
    private setTestCookie;
    getCookie(name: string): any;
    setCookie(name: string, value: any, expires?: Date): false | void | Cookies;
    getContent(modelName: string, options?: GetContentOptions): BehaviorSubject<BuilderContent[], any>;
    getAll(modelName: string, options?: GetContentOptions & {
        req?: IncomingMessage;
        res?: ServerResponse;
        apiKey?: string;
    }): Promise<BuilderContent[]>;
}
export {};
