"use strict";
/** @jsx jsx */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var sdk_1 = require("@builder.io/sdk");
var core_1 = require("@emotion/core");
var react_1 = __importDefault(require("react"));
var device_sizes_constant_1 = require("../constants/device-sizes.constant");
var set_1 = require("../functions/set");
var string_to_function_1 = require("../functions/string-to-function");
var builder_async_requests_1 = require("../store/builder-async-requests");
var builder_store_1 = require("../store/builder-store");
var apply_patch_with_mutation_1 = require("../functions/apply-patch-with-mutation");
var block_to_html_string_1 = require("../functions/block-to-html-string");
var Link_1 = require("./Link");
var camelCaseToKebabCase = function (str) {
    return str ? str.replace(/([A-Z])/g, function (g) { return "-" + g[0].toLowerCase(); }) : '';
};
var kebabCaseToCamelCase = function (str) {
    if (str === void 0) { str = ''; }
    return str.replace(/-([a-z])/g, function (match) { return match[1].toUpperCase(); });
};
var Device = { desktop: 0, tablet: 1, mobile: 2 };
var blocksMap = {};
var voidElements = new Set([
    'area',
    'base',
    'br',
    'col',
    'embed',
    'hr',
    'img',
    'input',
    'link',
    'meta',
    'param',
    'source',
    'track',
    'wbr',
]);
function pick(object, keys) {
    return keys.reduce(function (obj, key) {
        if (object && object.hasOwnProperty(key)) {
            obj[key] = object[key];
        }
        return obj;
    }, {});
}
var last = function (arr) { return arr[arr.length - 1]; };
function omit(obj, values) {
    var newObject = Object.assign({}, obj);
    for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
        var key = values_1[_i];
        delete newObject[key];
    }
    return newObject;
}
var cssCase = function (property) {
    if (!property) {
        return property;
    }
    var str = camelCaseToKebabCase(property);
    if (property[0] === property[0].toUpperCase()) {
        str = '-' + str;
    }
    return str;
};
// TODO: pull from builer internal utils
var fastClone = function (obj) { return JSON.parse(JSON.stringify(obj)); };
function mapToCss(map, spaces, important) {
    if (spaces === void 0) { spaces = 2; }
    if (important === void 0) { important = false; }
    return Object.keys(map).reduce(function (memo, key) {
        var value = map[key];
        if (typeof value !== 'string') {
            return memo;
        }
        return (memo +
            (value && value.trim()
                ? "\n" + ' '.repeat(spaces) + cssCase(key) + ": " + (value + (important ? ' !important' : '')) + ";"
                : ''));
    }, '');
}
function capitalize(str) {
    if (!str) {
        return;
    }
    return str[0].toUpperCase() + str.slice(1);
}
var BuilderBlock = /** @class */ (function (_super) {
    __extends(BuilderBlock, _super);
    function BuilderBlock() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            hasError: false,
            updates: 0,
        };
        _this.privateState = {
            state: {},
            rootState: {},
            context: {},
            update: function () {
                /* Intentionally empty */
            },
        };
        _this.onWindowMessage = function (event) {
            var message = event.data;
            if (!message) {
                return;
            }
            switch (message.type) {
                case 'builder.selectionChange': {
                    var data = message.data;
                    if (!data) {
                        break;
                    }
                    var selection = data.selection;
                    var id = _this.block && _this.block.id;
                    if (id && Array.isArray(selection) && selection.indexOf(id) > -1) {
                        setTimeout(function () {
                            window.$block = _this;
                            if (!window.$blocks) {
                                window.$blocks = [];
                            }
                            window.$blocks.push(_this);
                        });
                    }
                    break;
                }
                case 'builder.patchUpdates': {
                    var data = message.data;
                    if (!(data && data.data)) {
                        break;
                    }
                    var patches = data.data[_this.block.id];
                    if (!patches) {
                        return;
                    }
                    if (location.href.includes('builder.debug=true')) {
                        _this.eval('debugger');
                    }
                    var newBlock = __assign({}, _this.block);
                    for (var _i = 0, patches_1 = patches; _i < patches_1.length; _i++) {
                        var patch = patches_1[_i];
                        // TODO: soehow mark this.block as a new object,
                        // e.g. access it's parent hm. maybe do the listning mutations
                        // on hte parent element not the child (or rather
                        // send the message to the parent)
                        apply_patch_with_mutation_1.applyPatchWithMinimalMutationChain(newBlock, patch);
                    }
                    blocksMap[_this.props.block.id] = newBlock;
                    _this.setState({ updates: _this.state.updates + 1 });
                    break;
                }
            }
        };
        return _this;
    }
    Object.defineProperty(BuilderBlock.prototype, "store", {
        get: function () {
            return this.privateState;
        },
        enumerable: true,
        configurable: true
    });
    BuilderBlock.getDerivedStateFromError = function (error) {
        return { hasError: true };
    };
    BuilderBlock.prototype.componentDidCatch = function (error, errorInfo) {
        console.error('Builder block error:', error, errorInfo);
    };
    // TODO: handle adding return if none provided
    // TODO: cache/memoize this (globally with LRU?)
    BuilderBlock.prototype.stringToFunction = function (str, expression) {
        if (expression === void 0) { expression = true; }
        return string_to_function_1.stringToFunction(str, expression, this._errors, this._logs);
    };
    Object.defineProperty(BuilderBlock.prototype, "block", {
        get: function () {
            return blocksMap[this.props.block.id] || this.props.block;
        },
        enumerable: true,
        configurable: true
    });
    BuilderBlock.prototype.UNSAFE_componentWillReceiveProps = function (nextProps) {
        // Always keep our blocks map fresh
        if (sdk_1.Builder.isEditing && blocksMap[nextProps.block.id] !== nextProps.block) {
            blocksMap[nextProps.block.id] = nextProps.block;
        }
    };
    Object.defineProperty(BuilderBlock.prototype, "styles", {
        get: function () {
            // TODO: handle style bindings
            var size = this.props.size;
            var block = this.block;
            var styles = [];
            var startIndex = device_sizes_constant_1.sizeNames.indexOf(size || 'large');
            if (block.responsiveStyles) {
                for (var i = startIndex; i < device_sizes_constant_1.sizeNames.length; i = i + 1) {
                    var name_1 = device_sizes_constant_1.sizeNames[i];
                    if (block.responsiveStyles[name_1]) {
                        styles.push(block.responsiveStyles[name_1]);
                    }
                }
            }
            // On the server apply the initial animation state (TODO: maybe not for load time hm)
            // TODO: maybe /s/ server renders content pages hmm
            var isServer = !!this.privateState.state.isServer;
            var initialAnimationStepStyles;
            if (isServer) {
                var animation = block.animations && block.animations[0];
                var firstStep = animation && animation.steps && animation.steps[0];
                var stepStyles = firstStep && firstStep.styles;
                if (stepStyles) {
                    initialAnimationStepStyles = stepStyles;
                }
            }
            return Object.assign.apply(Object, __spreadArrays([{}], styles.reverse(), [initialAnimationStepStyles]));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BuilderBlock.prototype, "emotionCss", {
        get: function () {
            var _a, _b;
            var initialAnimationStepStyles;
            var block = this.block;
            if (sdk_1.Builder.isServer) {
                var animation = block.animations && block.animations[0];
                if (animation && animation.trigger !== 'hover') {
                    var firstStep = animation && animation.steps && animation.steps[0];
                    var stepStyles = firstStep && firstStep.styles;
                    if (stepStyles) {
                        initialAnimationStepStyles = stepStyles;
                    }
                }
            }
            var reversedNames = device_sizes_constant_1.sizeNames.slice().reverse();
            var self = this.block;
            var styles = {};
            if (self.responsiveStyles) {
                for (var _i = 0, reversedNames_1 = reversedNames; _i < reversedNames_1.length; _i++) {
                    var size = reversedNames_1[_i];
                    if (size === 'large') {
                        if (!this.props.emailMode) {
                            styles["&.builder-block"] = Object.assign({}, self.responsiveStyles[size], initialAnimationStepStyles);
                        }
                    }
                    else {
                        styles["@media only screen and (max-width: " + device_sizes_constant_1.sizes[size].max + "px)"] = {
                            '&.builder-block': self.responsiveStyles[size],
                        };
                    }
                }
            }
            var hoverAnimation = block.animations && block.animations.find(function (item) { return item.trigger === 'hover'; });
            if (hoverAnimation) {
                styles[':hover'] = ((_b = (_a = hoverAnimation.steps) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b.styles) || {};
                // TODO: if manually has set transition property deal with that
                // TODO: only include properties explicitly set in the animation
                // using Object.keys(styles)
                styles.transition = "all " + hoverAnimation.duration + "s " + camelCaseToKebabCase(hoverAnimation.easing);
                if (hoverAnimation.delay) {
                    styles.transitionDelay = hoverAnimation.delay + 's';
                }
            }
            return styles;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BuilderBlock.prototype, "css", {
        get: function () {
            // TODO: handle style bindings
            var self = this.block;
            var baseStyles = __assign({}, (self.responsiveStyles && self.responsiveStyles.large));
            var css = this.props.emailMode
                ? ''
                : ".builder-block." + self.id + " {" + mapToCss(baseStyles) + "}";
            var reversedNames = device_sizes_constant_1.sizeNames.slice().reverse();
            if (self.responsiveStyles) {
                for (var _i = 0, reversedNames_2 = reversedNames; _i < reversedNames_2.length; _i++) {
                    var size = reversedNames_2[_i];
                    if (this.props.emailMode && size === 'large') {
                        continue;
                    }
                    if (size !== 'large' &&
                        size !== 'xsmall' &&
                        self.responsiveStyles[size] &&
                        Object.keys(self.responsiveStyles[size]).length) {
                        var emailOuterSizes = ['display', 'width', 'verticalAlign'];
                        var map = self.responsiveStyles[size];
                        var outer = this.props.emailMode && pick(map, emailOuterSizes);
                        // TODO: this will not work as expected for a couple things that are handled specially,
                        // e.g. width
                        css += "\n@media only screen and (max-width: " + device_sizes_constant_1.sizes[size].max + "px) { \n" + (this.props.emailMode ? '.' : '.builder-block.') + (self.id + (this.props.emailMode ? '-subject' : '')) + " {" + mapToCss(this.props.emailMode ? omit(map, emailOuterSizes) : map, 4, this.props.emailMode) + " } }";
                        if (this.props.emailMode && outer && Object.keys(outer).length) {
                            css += "\n@media only screen and (max-width: " + device_sizes_constant_1.sizes[size].max + "px) { \n.builder-block." + self.id + " {" + mapToCss(outer, 4, true) + " } }";
                        }
                    }
                }
            }
            var animations = self.animations;
            if (!this.privateState.state.isBrowser && animations && animations.length) {
                var firstAnimation = animations[0];
                if (firstAnimation) {
                    var firstStep = firstAnimation.steps && firstAnimation.steps[0];
                    if (firstStep) {
                        var firstStepStyles = firstStep.styles;
                        if (firstStepStyles) {
                            css += "\n.builder-block." + self.id + " {" + mapToCss(firstStep, 2, true) + "}";
                        }
                    }
                }
            }
            return css;
        },
        enumerable: true,
        configurable: true
    });
    BuilderBlock.prototype.eval = function (str) {
        var fn = this.stringToFunction(str);
        // TODO: only one root instance of this, don't rewrap every time...
        return fn(this.privateState.state, undefined, this.block, sdk_1.builder, Device, this.privateState.update, sdk_1.Builder, this.privateState.context);
    };
    BuilderBlock.prototype.componentWillUnmount = function () {
        if (sdk_1.Builder.isEditing) {
            removeEventListener('message', this.onWindowMessage);
        }
    };
    BuilderBlock.prototype.componentDidMount = function () {
        var _this = this;
        var block = this.block;
        var animations = block && block.animations;
        if (sdk_1.Builder.isEditing) {
            addEventListener('message', this.onWindowMessage);
        }
        // tslint:disable-next-line:comment-format
        ///REACT15ONLY if (this.ref) { this.ref.setAttribute('builder-id', block.id); }
        if (animations) {
            var options = {
                animations: fastClone(animations),
            };
            // TODO: listen to Builder.editingMode and bind animations when editing
            // and unbind when not
            // TODO: apply bindings first
            if (block.bindings) {
                for (var key in block.bindings) {
                    if (key.startsWith('animations.')) {
                        // TODO: this needs to run in getElement bc of local state per element for repeats
                        var value = this.stringToFunction(block.bindings[key]);
                        if (value !== undefined) {
                            set_1.set(options, key, value(this.privateState.state, null, block, sdk_1.builder, null, null, sdk_1.Builder, this.privateState.context));
                        }
                    }
                }
            }
            sdk_1.Builder.animator.bindAnimations(options.animations
                .filter(function (item) { return item.trigger !== 'hover'; })
                .map(function (animation) { return (__assign(__assign({}, animation), { elementId: _this.block.id })); }));
        }
    };
    // <!-- Builder Blocks --> in comments hmm
    BuilderBlock.prototype.getElement = function (index, state) {
        var _a;
        var _this = this;
        if (index === void 0) { index = 0; }
        if (state === void 0) { state = this.privateState.state; }
        var _b, _c;
        var _d = this.props, child = _d.child, fieldName = _d.fieldName;
        var block = this.block;
        var TagName = (block.tagName || 'div').toLowerCase();
        if (TagName === 'template') {
            var html = block.children
                ? block.children.map(function (item) { return block_to_html_string_1.blockToHtmlString(item); }).join(' ')
                : '';
            console.debug('template html', html);
            return (
            // React has an undesired behavior (for us) for template tags, so we must
            // turn the contents into a string
            core_1.jsx("template", __assign({}, block.properties, { dangerouslySetInnerHTML: {
                    __html: html,
                } })));
        }
        var InnerComponent;
        var componentName = block.component && (block.component.name || block.component.component);
        var componentInfo = null;
        if (block.component && !block.component.class) {
            if (block.component && block.component.tag) {
                InnerComponent = block.component.tag;
            }
            else {
                componentInfo = sdk_1.Builder.components.find(function (item) { return item.name === componentName; }) || null;
                if (componentInfo && componentInfo.class) {
                    InnerComponent = componentInfo.class;
                }
                else if (componentInfo && componentInfo.tag) {
                    InnerComponent = componentInfo.tag;
                }
            }
        }
        var TextTag = 'span';
        var options = __assign(__assign({}, block.properties), { style: {} });
        options = __assign(__assign({}, options.properties), options);
        if (block.component) {
            options.component = fastClone(block.component);
        }
        // Binding should be properties to href or href?
        // Manual style editor show bindings
        // Show if things bound in overlays hmm
        if (block.bindings) {
            for (var key in block.bindings) {
                var value = this.stringToFunction(block.bindings[key]);
                // TODO: pass block, etc
                set_1.set(options, key, value(state, null, block, string_to_function_1.api(state), Device, null, sdk_1.Builder, this.privateState.context));
            }
        }
        if (options.hide) {
            return null;
        }
        else {
            delete options.hide;
        }
        // TODO: UI for this
        if (('show' in options || (block.bindings && block.bindings.show)) && !options.show) {
            return null;
        }
        else {
            delete options.show;
        }
        if (block.actions) {
            var _loop_1 = function (key) {
                var value = block.actions[key];
                options['on' + capitalize(key)] = function (event) {
                    var useState = state;
                    if (typeof Proxy !== 'undefined') {
                        useState = new Proxy(state, {
                            set: function (obj, prop, value) {
                                obj[prop] = value;
                                _this.privateState.rootState[prop] = value;
                                return true;
                            },
                        });
                    }
                    var fn = _this.stringToFunction(value, false);
                    // TODO: only one root instance of this, don't rewrap every time...
                    return fn(useState, event, _this.block, sdk_1.builder, Device, _this.privateState.update, sdk_1.Builder, _this.privateState.context);
                };
            };
            for (var key in block.actions) {
                _loop_1(key);
            }
        }
        var innerComponentProperties = (options.component || options.options) && __assign(__assign({}, options.options), (options.component.options || options.component.data));
        var isVoid = voidElements.has(TagName);
        var noWrap = componentInfo && (componentInfo.fragment || componentInfo.noWrap);
        var styleStr = ((_b = options.attr) === null || _b === void 0 ? void 0 : _b.style) || (typeof options.style === 'string' ? options.style : '') || '';
        if (typeof styleStr === 'string') {
            if (typeof options.style !== 'object') {
                options.style = {};
            }
            var styleSplit = styleStr.split(';');
            for (var _i = 0, styleSplit_1 = styleSplit; _i < styleSplit_1.length; _i++) {
                var pair = styleSplit_1[_i];
                var stylePieces = pair.split(':');
                if (!stylePieces.length) {
                    return;
                }
                var key = stylePieces[0], value = stylePieces[1];
                if (stylePieces.length > 2) {
                    value = stylePieces.slice(1).join(':');
                }
                options.style[kebabCaseToCamelCase(key)] = value;
            }
        }
        var finalOptions = __assign(__assign(__assign({}, omit(options, ['class', 'component', 'attr'])), (_a = {}, _a[typeof TagName === 'string' && !TagName.includes('-') ? 'className' : 'class'] = "builder-block " + this.id + (block.class ? " " + block.class : '') + (block.component && !(['Image', 'Video', 'Banner'].indexOf(componentName) > -1)
            ? " builder-has-component"
            : '') +
            (options.class ? ' ' + options.class : '') +
            (sdk_1.Builder.isEditing && ((_c = this.privateState.state._spacer) === null || _c === void 0 ? void 0 : _c.parent) === block.id
                ? ' builder-spacer-parent'
                : ''), _a.key = this.id + index, _a['builder-id'] = this.id, _a)), (index !== 0 && {
            'builder-index': index,
        }));
        // tslint:disable-next-line:comment-format
        ///REACT15ONLY finalOptions.className = finalOptions.class
        if (sdk_1.Builder.isIframe) {
            // TODO: removed bc JS can add styles inline too?
            finalOptions['builder-inline-styles'] = !(options.attr && options.attr.style)
                ? ''
                : Object.keys(options.style).reduce(function (memo, key) { return (memo ? memo + ";" : '') + (cssCase(key) + ":" + options.style[key] + ";"); }, '');
        }
        if (((finalOptions.properties && finalOptions.properties.href) ||
            finalOptions.href) &&
            TagName === 'div') {
            TagName = 'a';
        }
        if (TagName === 'a') {
            TagName = Link_1.Link;
        }
        // const css = this.css
        // const styleTag = css.trim() && (
        //   <style className="builder-style">
        //     {(InnerComponent && !isBlock ? `.${this.id} > * { height: 100%; width: 100%; }` : '') +
        //       this.css}
        //   </style>
        // )
        var children = block.children || finalOptions.children || [];
        // TODO: test it out
        return (core_1.jsx(react_1.default.Fragment, null,
            core_1.jsx(core_1.ClassNames, null, function (_a) {
                var css = _a.css, cx = _a.cx;
                if (!_this.props.emailMode) {
                    var addClass = ' ' + css(_this.emotionCss);
                    if (finalOptions.class) {
                        finalOptions.class += addClass;
                    }
                    if (finalOptions.className) {
                        finalOptions.className += addClass;
                    }
                }
                return (core_1.jsx(builder_async_requests_1.BuilderAsyncRequestsContext.Consumer, null, function (value) {
                    _this._asyncRequests = value && value.requests;
                    _this._errors = value && value.errors;
                    _this._logs = value && value.logs;
                    return isVoid ? (core_1.jsx(TagName, __assign({}, finalOptions))) : InnerComponent && (noWrap || _this.props.emailMode) ? (
                    // TODO: pass the class to be easier
                    // TODO: acceptsChildren option?
                    core_1.jsx(InnerComponent
                    // Final options maaay be wrong here hm
                    , __assign({}, innerComponentProperties, { 
                        // should really call this builderAttributes bc people can name a
                        // componet input "attributes"
                        attributes: finalOptions, builderBlock: block, builderState: _this.privateState }))) : (core_1.jsx(TagName, __assign({}, finalOptions),
                        InnerComponent && (core_1.jsx(InnerComponent, __assign({ builderState: _this.privateState, builderBlock: block }, innerComponentProperties))),
                        block.text || options.text
                            ? options.text
                            : !InnerComponent && children && Array.isArray(children) && children.length
                                ? children.map(function (block, index) { return (core_1.jsx(BuilderBlock, { key: (_this.id || '') + index, block: block, index: index, size: _this.props.size, fieldName: _this.props.fieldName, child: _this.props.child, emailMode: _this.props.emailMode })); })
                                : null));
                }));
            })));
    };
    Object.defineProperty(BuilderBlock.prototype, "id", {
        get: function () {
            var block = this.block;
            if (!block.id.startsWith('builder')) {
                return 'builder-' + block.id;
            }
            return block.id;
        },
        enumerable: true,
        configurable: true
    });
    BuilderBlock.prototype.contents = function (state) {
        var _this = this;
        var block = this.block;
        // this.setState(state);
        this.privateState = state;
        if (block.repeat && block.repeat.collection) {
            var collectionPath = block.repeat.collection;
            var collectionName = last((collectionPath || '').trim().split('(')[0].trim().split('.'));
            var itemName_1 = block.repeat.itemName || (collectionName ? collectionName + 'Item' : 'item');
            var array = this.stringToFunction(collectionPath)(state.state, null, block, string_to_function_1.api(state), Device, null, sdk_1.Builder, this.privateState.context);
            if (Array.isArray(array)) {
                return array.map(function (data, index) {
                    var _a;
                    // TODO: Builder state produce the data
                    var childState = __assign(__assign({}, state.state), (_a = { $index: index, $item: data }, _a[itemName_1] = data, _a["$" + itemName_1 + "Index"] = index, _a));
                    return (core_1.jsx(builder_store_1.BuilderStoreContext.Provider, { key: index, value: __assign(__assign({}, state), { state: childState }) }, _this.getElement(index, childState)));
                });
            }
            return null;
        }
        return this.getElement();
    };
    BuilderBlock.prototype.render = function () {
        var _this = this;
        if (this.state.hasError) {
            return (core_1.jsx("span", { css: {
                    display: 'inline-block',
                    padding: 5,
                    color: '#999',
                    fontSize: 11,
                    fontStyle: 'italic',
                } }, "Builder block error :( Check console for details"));
        }
        return (core_1.jsx(builder_store_1.BuilderStoreContext.Consumer, null, function (value) { return _this.contents(value); }));
    };
    return BuilderBlock;
}(react_1.default.Component));
exports.BuilderBlock = BuilderBlock;
//# sourceMappingURL=builder-block.component.js.map